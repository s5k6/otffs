
`otfFS` — File system of on-the-fly test data
==============================================

Goal
----

Provide arbitrarily large files of pseudo-random test data, without
consuming disk space.

Use case:

    $ curl 'http://localhost:8080/mnt/data3' | cmp - ./mnt/data3

You don't want to create these files on your SSD:

    $ ls -l mnt
    -r--r--r-- 1 sk users 4.1k Jan  1 21:09 data1
    -r--r--r-- 1 sk users 4.2M Jan  1 21:09 data2
    -r--r--r-- 1 sk users 4.3G Jan  1 21:09 data3
    -r--r--r-- 1 sk users 4.4T Jan  1 21:09 data4
    -r--r--r-- 1 sk users 4.6P Jan  1 21:09 data5

Plan: Use FUSE [1] to provide a file system, which is backed by an
executable instead of disk space.  Reading from a file in this
on-the-fly FS delivers data from a pseudo random number generator.
Thus, every read a the same offset of the same file will produce the
same data.


Using
-----

    $ make

Create mountpoint directory, and add some files:

    $ mkdir mnt
    $ date > mnt/realfile

Run `otffs` on top of `mnt`, maybe do this in another terminal.

    $ ./otffs mnt

Check out the files in `mnt`, try to read the large ones...

    $ ls -l mnt
    total 0
    -r--r--r-- 1 sk users 4.1k Jan  1 21:21 data1
    -r--r--r-- 1 sk users 4.2M Jan  1 21:21 data2
    -r--r--r-- 1 sk users 4.3G Jan  1 21:21 data3
    -r--r--r-- 1 sk users 4.4T Jan  1 21:21 data4
    -r--r--r-- 1 sk users 4.6P Jan  1 21:21 data5
    -r-------- 1 sk users   29 Jan  1 21:21 realfile


Common error messages
---------------------

  * “fuse: device not found, try 'modprobe fuse' first”

    Have you upgraded the kernel?  Reboot.

  * “The source `foo` is too short (29B).  Request of 65536B for `bar`
    needs IOVEC of size 2260, limit is 1024!”

    Reading from fake file `bar` sent a read(2) request to the file
    system, asking for 65536 bytes.  So we need to concatenate 2260
    copies of source file `foo`.  Your system cannot do that
    efficiently, and I have not implemented the less efficient method.
    See readv(2) and look for `IOV_MAX`.  You can solve this problem
    by providing a source `foo` for which

                             max amount of data req'd by read
        filesize of foo  >  ----------------------------------
                                        IOV_MAX

    holds.

  * “cannot access 'mnt': Transport endpoint is not connected”

    The `otffs` process crashed, abd the OS still thinks the
    mountpoint is mounted.  Umount the mountpoint, using

        $ fusermount -u mnt


TODO
====

Fails if less than 2 entries in config.

AVL tree.

Data is not pseudorandom, but plain enumeration of 4-byte integers.

Right now, the number, names, sizes, modes, and contents of the fake
files are fixed.  Make this configurable.


Learning from others
====================

    $ https://github.com/libfuse/libfuse.git
    $ cd libfuse/example/
    $ gcc -Wall hello.c $(pkg-config fuse3 --cflags --libs) -o hello

Make mountpoint `mnt`.  Run in foreground (`-f`), and set user and
group from the `mnt` directory.  Maybe do this in a separate terminal:

    $ mkdir mnt
    $ ./hello -f $(stat -c '-o uid=%u -o gid=%g' mnt) mnt

Umounting is by terminating the program (through an exit handler it
has installed), or through

    $ fusermount -u mnt



____________________
[1] https://github.com/libfuse/libfuse/
